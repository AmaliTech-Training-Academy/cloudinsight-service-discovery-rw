name: Backend Service CI (No Tests)

permissions:
  contents: write
  checks: write
  actions: read
  id-token: write

concurrency:
  group: backend-ci-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: cloudinsight

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: "21"
          distribution: "temurin"
          cache: maven

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Build with Maven
        run: |
          mvn clean compile -DskipTests=true \
            -Dmaven.javadoc.skip=true \
            -B -V

      - name: Package application
        run: |
          mvn package -DskipTests=true \
            -Dmaven.javadoc.skip=true \
            -B

      - name: Decrypt environment variables (optional)
        id: decrypt-env
        run: |
          echo "üîç Checking for encrypted environment files..."
          cleanup() { rm -f ./team-private-key.pem ./temp-aes-key; }
          trap cleanup EXIT
          ENCRYPTED_DATA=$(find . -maxdepth 1 -name "encrypted-env-vars.enc" -type f | head -1)
          ENCRYPTED_KEY=$(find . -maxdepth 1 -name "encrypted-aes-key.enc" -type f | head -1)
          if [[ -z "$ENCRYPTED_DATA" || -z "$ENCRYPTED_KEY" ]]; then
            echo "‚ÑπÔ∏è No encrypted env files found - skipping deployment"
            echo "has_encrypted_env=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "${{ secrets.TEAM_PRIVATE_KEY }}" > ./team-private-key.pem; chmod 600 ./team-private-key.pem
          openssl rsautl -decrypt -inkey ./team-private-key.pem -in "$ENCRYPTED_KEY" -out ./temp-aes-key
          AES_KEY=$(cat ./temp-aes-key)
          if ! openssl enc -aes-256-gcm -d -in "$ENCRYPTED_DATA" -out "./.env" -pass "pass:$AES_KEY" 2>/dev/null; then
            openssl enc -aes-256-cbc -d -in "$ENCRYPTED_DATA" -out "./.env" -pass "pass:$AES_KEY" 2>/dev/null || { echo "‚ùå Decrypt failed"; exit 1; }
          fi
          if [[ -f ./.env ]]; then
            echo "‚úÖ Environment variables decrypted successfully"
            grep -q '^\.env$' .gitignore 2>/dev/null || echo ".env" >> .gitignore
            git add .gitignore 2>/dev/null || true
            echo "has_encrypted_env=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Failed to create .env file"
            echo "has_encrypted_env=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Deploy environment variables to AWS Secrets Manager
        if: steps.decrypt-env.outputs.has_encrypted_env == 'true'
        run: |
          echo "üöÄ Deploying environment variables to AWS Secrets Manager..."
          SECRET_NAME="${{ secrets.AWS_SECRET_NAME_BACKEND }}"
          if [[ -z "$SECRET_NAME" ]]; then
            echo "‚ùå AWS_SECRET_NAME_BACKEND secret not configured"
            exit 1
          fi

          # Remove database secrets from .env before processing
          echo "üö´ Removing database secrets (DB_PASSWORD, DB_URL, DB_USERNAME) from environment variables..."
          sed -i '/^DB_PASSWORD=/d; /^DB_URL=/d; /^DB_USERNAME=/d' .env

          echo "üìä Remaining environment variables after database secret exclusion:"
          grep -c "^[^#].*=" .env || echo "0"

          # Function to clean and process values
          clean_value() {
            local raw_value="$1"
            
            # Remove carriage returns, newlines, tabs, and other control characters
            local cleaned_value=$(echo "$raw_value" | tr -d '\r\n\t' | sed 's/[[:cntrl:]]//g')
            
            # Trim leading and trailing whitespace
            cleaned_value=$(echo "$cleaned_value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            
            # Check if value is a pure integer (no decimals)
            if [[ "$cleaned_value" =~ ^-?[0-9]+$ ]]; then
              # Return as integer (remove quotes in JSON)
              echo "$cleaned_value"
            # Check if value is a decimal number
            elif [[ "$cleaned_value" =~ ^-?[0-9]+\.[0-9]+$ ]]; then
              # Return as number (remove quotes in JSON)
              echo "$cleaned_value"
            # Check if value is a boolean
            elif [[ "$cleaned_value" =~ ^(true|false)$ ]]; then
              # Return as boolean (remove quotes in JSON)
              echo "$cleaned_value"
            else
              # Return as string (keep quotes in JSON)
              echo "\"$cleaned_value\""
            fi
          }

          # Create JSON using jq to properly escape all characters
          echo "{}" > /tmp/new.json
          while IFS='=' read -r key value || [ -n "$key" ]; do
            # Skip empty lines and comment lines
            if [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]]; then
              continue
            fi
            
            # Remove inline comments from value (everything after # including the #)
            value=$(echo "$value" | sed 's/[[:space:]]*#.*$//')
            
            if [[ -n "$key" && -n "$value" ]]; then
              # Clean the value and determine its type
              cleaned_value=$(clean_value "$value")
              
              # Check if cleaned_value is already properly formatted (number/boolean)
              if [[ "$cleaned_value" =~ ^-?[0-9]+(\.[0-9]+)?$|^(true|false)$ ]]; then
                # Add as raw value (number or boolean)
                jq --arg k "$key" --argjson v "$cleaned_value" '. + {($k): $v}' /tmp/new.json > /tmp/temp.json && mv /tmp/temp.json /tmp/new.json
              else
                # Remove quotes and add as string value
                string_value=$(echo "$cleaned_value" | sed 's/^"//;s/"$//')
                jq --arg k "$key" --arg v "$string_value" '. + {($k): $v}' /tmp/new.json > /tmp/temp.json && mv /tmp/temp.json /tmp/new.json
              fi
              
              echo "  üîë Processed $key: $cleaned_value"
            fi
          done < .env

          # Check if secret exists and deploy as key-value pairs
          if aws secretsmanager describe-secret --secret-id "$SECRET_NAME" >/dev/null 2>&1; then
            echo "‚úÖ Secret exists, updating individual key-value pairs..."
            
            # Get existing secret and merge with new values
            EXISTING_SECRET=$(aws secretsmanager get-secret-value --secret-id "$SECRET_NAME" --query SecretString --output text)
            echo "$EXISTING_SECRET" > /tmp/existing.json
            
            # Create new values JSON with cleaned values
            echo "{}" > /tmp/new_vars.json
            while IFS='=' read -r key value || [ -n "$key" ]; do
              if [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]]; then continue; fi
              value=$(echo "$value" | sed 's/[[:space:]]*#.*$//')
              if [[ -n "$key" && -n "$value" ]]; then
                echo "  üîë Processing key: $key"
                
                # Clean the value and determine its type
                cleaned_value=$(clean_value "$value")
                
                # Check if cleaned_value is already properly formatted (number/boolean)
                if [[ "$cleaned_value" =~ ^-?[0-9]+(\.[0-9]+)?$|^(true|false)$ ]]; then
                  # Add as raw value (number or boolean)
                  jq --arg k "$key" --argjson v "$cleaned_value" '. + {($k): $v}' /tmp/new_vars.json > /tmp/temp_vars.json && mv /tmp/temp_vars.json /tmp/new_vars.json
                else
                  # Remove quotes and add as string value
                  string_value=$(echo "$cleaned_value" | sed 's/^"//;s/"$//')
                  jq --arg k "$key" --arg v "$string_value" '. + {($k): $v}' /tmp/new_vars.json > /tmp/temp_vars.json && mv /tmp/temp_vars.json /tmp/new_vars.json
                fi
              fi
            done < .env
            
            # Merge existing with new values
            jq -s '.[0] * .[1]' /tmp/existing.json /tmp/new_vars.json > /tmp/merged.json
            
            # Update secret
            aws secretsmanager update-secret --secret-id "$SECRET_NAME" --secret-string file:///tmp/merged.json
            echo "‚úÖ Secret updated successfully with merged key-value pairs"
            
            # Cleanup merge files
            rm -f /tmp/existing.json /tmp/new_vars.json /tmp/merged.json
          else
            echo "üÜï Creating new secret with key-value pairs..."
            
            # Create JSON with all key-value pairs using cleaned values
            echo "{}" > /tmp/new.json
            while IFS='=' read -r key value || [ -n "$key" ]; do
              if [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]]; then continue; fi
              value=$(echo "$value" | sed 's/[[:space:]]*#.*$//')
              if [[ -n "$key" && -n "$value" ]]; then
                echo "  üîë Adding key: $key"
                
                # Clean the value and determine its type
                cleaned_value=$(clean_value "$value")
                
                # Check if cleaned_value is already properly formatted (number/boolean)
                if [[ "$cleaned_value" =~ ^-?[0-9]+(\.[0-9]+)?$|^(true|false)$ ]]; then
                  # Add as raw value (number or boolean)
                  jq --arg k "$key" --argjson v "$cleaned_value" '. + {($k): $v}' /tmp/new.json > /tmp/temp_new.json && mv /tmp/temp_new.json /tmp/new.json
                else
                  # Remove quotes and add as string value
                  string_value=$(echo "$cleaned_value" | sed 's/^"//;s/"$//')
                  jq --arg k "$key" --arg v "$string_value" '. + {($k): $v}' /tmp/new.json > /tmp/temp_new.json && mv /tmp/temp_new.json /tmp/new.json
                fi
              fi
            done < .env
            
            # Create new secret
            aws secretsmanager create-secret --name "$SECRET_NAME" --description "Backend environment variables for ${{ github.repository }}" --secret-string file:///tmp/new.json
            echo "‚úÖ Secret created successfully with all key-value pairs"
            
            # Cleanup
            rm -f /tmp/new.json
          fi

          echo "üîê Environment variables deployed to AWS Secrets Manager: $SECRET_NAME"
          echo "üö´ Database secrets (DB_PASSWORD, DB_URL, DB_USERNAME) excluded from deployment"

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Calculate next semantic version
        id: semver
        run: |
          echo "üè∑Ô∏è Calculating next semantic version for branch: ${{ github.ref_name }}"
          BRANCH_NAME="${{ github.ref_name }}"
          LATEST_TAG=$(git tag -l --sort=-version:refname "v*-${BRANCH_NAME}" | head -1 || echo "")
          if [[ -z "$LATEST_TAG" ]]; then
            LATEST_TAG=$(git describe --tags --abbrev=0 --match="v*" 2>/dev/null || echo "v0.0.0")
            LATEST_TAG=$(echo "$LATEST_TAG" | sed 's/-[^-]*$//')
          else
            LATEST_TAG=$(echo "$LATEST_TAG" | sed 's/-[^-]*$//')
          fi
          if [[ $LATEST_TAG =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            MAJOR=${BASH_REMATCH[1]}
            MINOR=${BASH_REMATCH[2]}
            PATCH=${BASH_REMATCH[3]}
            PATCH=$((PATCH + 1))
          else
            MAJOR=0; MINOR=1; PATCH=0
          fi
          NEXT_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "version_no_v=${MAJOR}.${MINOR}.${PATCH}" >> $GITHUB_OUTPUT

      - name: Extract service name
        id: service
        run: |
          REPO_NAME="${{ github.repository }}"
          SERVICE_NAME=$(echo "$REPO_NAME" | sed 's/.*cloudinsight-\(.*\)-rw/\1/')
          echo "name=$SERVICE_NAME" >> $GITHUB_OUTPUT

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64,linux/arm64

      - name: Build and push multi-platform Docker image to ECR
        if: github.event_name != 'pull_request'
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: |
            ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY_BACKEND }}:${{ steps.semver.outputs.version }}
            ${{ secrets.ECR_REGISTRY }}/${{ secrets.ECR_REPOSITORY_BACKEND }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Create and push git tag
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          TAG_NAME="${{ steps.semver.outputs.version }}-${BRANCH_NAME}"
          if git tag -l "$TAG_NAME" | grep -q "$TAG_NAME"; then
            echo "‚ö†Ô∏è Tag $TAG_NAME already exists, skipping"
            exit 0
          fi
          git tag -a "$TAG_NAME" -m "Backend release ${{ steps.semver.outputs.version }} from branch $BRANCH_NAME"
          git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git "$TAG_NAME"

      - name: Cleanup sensitive files
        if: always() && steps.decrypt-env.outputs.has_encrypted_env == 'true'
        run: |
          echo "üßπ Cleaning up sensitive files..."
          rm -f ./.env ./team-private-key.pem ./temp-aes-key
